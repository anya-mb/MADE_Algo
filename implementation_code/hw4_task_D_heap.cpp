/* –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∞–º–æ–ø–∏—Å–Ω—É—é –∫—É—á—É, –∫–æ—Ç–æ—Ä—É—é –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –Ω–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º —Å–∞–º–æ—Ä–∞—Å—à–∏—Ä—è—é—â–µ–º—Å—è –º–∞—Å—Å–∏–≤–µ.
 *
 * D. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å ‚Äì 2
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Ç–µ—Å—Ç: 3 —Å–µ–∫—É–Ω–¥—ã
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –ø–∞–º—è—Ç–∏ –Ω–∞ —Ç–µ—Å—Ç: 256 –º–µ–≥–∞–±–∞–π—Ç
–≤–≤–æ–¥: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤–≤–æ–¥
–≤—ã–≤–æ–¥: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥

–†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—É—é –æ—á–µ—Ä–µ–¥—å. –í–∞—à–∞ –æ—á–µ—Ä–µ–¥—å –¥–æ–ª–∂–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏: –¥–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç, –∏–∑–≤–ª–µ—á—å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç, —É–º–µ–Ω—å—à–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç, –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π –≤–æ –≤—Ä–µ–º—è –æ–¥–Ω–æ–π –∏–∑ –æ–ø–µ—Ä–∞—Ü–∏–π.

–ï—Å–ª–∏ –∫–∞–∫–æ–π-–Ω–∏–±—É–¥—å decrease-key —É–º–µ–Ω—å—à–∞–µ—Ç —É–∂–µ —É–¥–∞–ª–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç, —Ç–æ –Ω–∏—á–µ–≥–æ –¥–µ–ª–∞—Ç—å –Ω–µ –Ω—É–∂–Ω–æ.

–í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω—É–º–µ—Ä—É—é—Ç—Å—è –ø–æ –ø–æ—Ä—è–¥–∫—É, –Ω–∞—á–∏–Ω–∞—è —Å 1.

–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–°–æ–¥–µ—Ä–∂–∏—Ç—Å—è –æ–ø–∏—Å–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π —Å–æ –æ—á–µ—Ä–µ–¥—å—é. –í –æ—á–µ—Ä–µ–¥—å –ø–æ–º–µ—â–∞—é—Ç—Å—è –∏ –∏–∑–≤–ª–µ–∫–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞, –Ω–µ –ø—Ä–µ–≤—ã—à–∞—é—â–∏–µ 10^9 –ø–æ –∞–±—Å–æ–ª—é—Ç–Ω–æ–π –≤–µ–ª–∏—á–∏–Ω–µ.

–ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç—Å—è, —á—Ç–æ –¥–ª—è –ª—é–±–æ–≥–æ decrease-key x v –∏–∑ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏—è –ø–æ–¥ –Ω–æ–º–µ—Ä–æ–º ùë• —è–≤–ª—è–µ—Ç—Å—è push.

–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–í—ã–≤–µ–¥–∏—Ç–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π extract-min –∏–∑ –¥–≤—É—Ö —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª: –∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –∏ –Ω–æ–º–µ—Ä –æ–ø–µ—Ä–∞—Ü–∏–∏ push, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º —ç—Ç–æ—Ç —ç–ª–µ–º–µ–Ω—Ç –±—ã–ª –¥–æ–±–∞–≤–ª–µ–Ω. –ï—Å–ª–∏ –≤ –æ—á–µ—Ä–µ–¥–∏ –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –≤—ã–≤–µ–¥–∏—Ç–µ –ª—é–±–æ–π. –ï—Å–ª–∏ –ø–µ—Ä–µ–¥ –æ—á–µ—Ä–µ–¥–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π extract-min –æ—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞, –≤—ã–≤–µ–¥–∏—Ç–µ –∑–≤–µ–∑–¥–æ—á–∫—É.

–ü—Ä–∏–º–µ—Ä
–≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
push 3
push 4
push 2
extract-min
decrease-key 2 1
extract-min
extract-min
extract-min

–≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
2 3
1 2
3 1
*

 */


#include <iostream>
#include <string>
#include <assert.h>
#include <vector>

using std::cin;
using std::cout;
using std::vector;
using std::string;

class Entity {
    int value;
    int op_number;
    int idx;
public:
    Entity(int value, int opNumber, int idx) : value(value), op_number(opNumber), idx(idx) {}

    int getValue() const {
        return value;
    }

    int getOpNumber() const {
        return op_number;
    }

    void setIdx(int idx) {
        Entity::idx = idx;
    }

    virtual ~Entity() {

    }

    void setValue(int value) {
        Entity::value = value;
    }

    int getIdx() const {
        return idx;
    }
};

class Heap {
public:
    void insert(int value_to_add);

    std::pair<int, int> remove_min();

    void decrease_key(int operation_number, int new_value);

private:
    vector<Entity *> elements;

    vector<Entity *> elements_in_push_order;

    int op_number = 1;

    void swap(Entity *i, Entity *j);

    void sieve_up(int idx);

    void sieve_down();

    int get_parent_idx(int i) {
        return (i - 1) / 2;
    }

    int get_left_child_idx(int i) {
        return 2 * i + 1;
    }

    int get_right_child_idx(int i) {
        return 2 * i + 2;
    }

    void increase_op_number() {
        op_number++;
        elements_in_push_order.push_back(nullptr);
    }
};

void Heap::insert(int value_to_add) {
    Entity *new_pair = new Entity(value_to_add, op_number++, elements.size());
    elements.push_back(new_pair);
    sieve_up(elements.size() - 1);
    elements_in_push_order.push_back(new_pair);
}

std::pair<int, int> Heap::remove_min() {
    increase_op_number();
    if (elements.empty()) {
        return std::make_pair(-1, -1);
    }
    Entity *min_pair = elements.at(0);
    int min_value = min_pair->getValue();
    int push_num = min_pair->getOpNumber();
    delete min_pair;

    elements.at(0) = elements.at(elements.size() - 1);
    elements.at(0)->setIdx(0);
    elements.pop_back();
    elements_in_push_order.at(push_num - 1) = nullptr;
    sieve_down();

    return std::pair<int, int>(min_value, push_num);
}

void Heap::sieve_down() {
    if (elements.empty()) return;
    Entity *entity = elements.at(0);
    while (get_left_child_idx(entity->getIdx()) < elements.size()) {
        Entity *left_child = elements.at(get_left_child_idx(entity->getIdx()));
        // no right child
        if (get_right_child_idx(entity->getIdx()) >= elements.size()) {
            if (entity->getValue() > left_child->getValue()) {
                swap(entity, left_child);
            }
            return;
        }
        Entity *right_child = elements.at(get_right_child_idx(entity->getIdx()));

        Entity *min_child;
        if (left_child->getValue() < right_child->getValue()) {
            min_child = left_child;
        } else {
            min_child = right_child;
        }

        if (entity->getValue() > min_child->getValue()) {
            swap(entity, min_child);
        } else {
            return;
        }
    }
}

void Heap::sieve_up(int idx) {
    Entity *entity = elements.at(idx);
    while (entity->getIdx() != 0) {
        Entity *parent = elements.at(get_parent_idx(entity->getIdx()));
        if (entity->getValue() >= parent->getValue()) {
            return;
        }
        swap(entity, parent);
    }
}

void Heap::decrease_key(int operation_number, int new_value) {
    increase_op_number();
    if (elements_in_push_order.at(operation_number - 1) == nullptr) return;
    Entity *entity = elements_in_push_order.at(operation_number - 1);
    entity->setValue(new_value);
    sieve_up(entity->getIdx());

}

void Heap::swap(Entity *e1, Entity *e2) {
    int i = e1->getIdx();
    int j = e2->getIdx();
    e1->setIdx(j);
    e2->setIdx(i);

    elements.at(i) = e2;
    elements.at(j) = e1;
}

void t1() {
    Heap heap;
    heap.insert(2);
    auto result = heap.remove_min();
    assert(result.first == 2);
    assert(result.second == 1);
}

void t2() {
    Heap heap;
    heap.insert(10);
    heap.insert(15);
    heap.insert(1);
    heap.decrease_key(2, 3);
    auto r1 = heap.remove_min();
    assert(r1.first == 1);
    assert(r1.second == 3);

    auto r2 = heap.remove_min();
    assert(r2.first == 3);
    assert(r2.second == 2);

    heap.decrease_key(3, -1);

    auto r3 = heap.remove_min();
    assert(r3.first == 10);
    assert(r3.second == 1);

    auto r4 = heap.remove_min();
    assert(r4.second == -1);
    assert(r4.first == -1);

}

void test() {
    t1();
    t2();
}

void input() {
    string operation;
    Heap heap;
    while (cin >> operation) {
        if (operation == std::string("push")) {

            int value_to_push;
            cin >> value_to_push;

            heap.insert(value_to_push);

        } else if (operation == std::string("extract-min")) {

            std::pair<int, int> min_info = heap.remove_min();
            if (min_info.second < 0) {
                cout << "*" << std::endl;
            } else {
                cout << min_info.first << " " << min_info.second << std::endl;
            }

        } else if (operation == std::string("decrease-key")) {
            int x_push_operation_number, v_new_value;

            cin >> x_push_operation_number >> v_new_value;

            heap.decrease_key(x_push_operation_number, v_new_value);

        } else {
            throw;
        }

    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    input();
//    test();

    return 0;
}